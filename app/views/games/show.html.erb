<style>

*
{
    box-sizing: border-box;
    --board-y: 50vh;
    --board-x: 100vh;
}

@media (orientation: portrait)
{
    *
    {
        --board-y: 50vw;
        --board-x: 100vw;
    }

}

body
{
    margin: 0;
    overflow: hidden;
    height: 100vh;
}

#game
{
    touch-action: none;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    height: 100%;
}

#board
{
    width: var(--board-x);
    height: var(--board-y);
    flex: unset;
}

#board-holder
{
    display: flex;
    justify-content: center;
    align-items: center;
}

.dragitem
{
    transition: transform 0.25s;
    border-radius: 50%;
    line-height: 100%;
    font-size: calc(15vmin * var(--scale, 1));
}

.dropzone
{
    /*
    width: 50vmin;
    height: 35vmax;
    */
    position: relative;
    display: inline-block;
    outline: 1px solid black;
    flex: 1; /* => grow: 1 shrink: 1 basis: 0 */
}

#main > .dragitem
{

}

.dropzone-active
{
    box-shadow: inset 0px 0px 20px rgba(255, 100, 100, 0.5);
}

.dragitem-dragging
{
    /*transform: scale(300%);*/
    z-index: 10;
    position: absolute;
}

#hand
{
    padding: 3vmin;
}

.vis-hid
{
    visibility: hidden;
}

#judge
{
    width: 100vw;
    height: 100vh;
    display: grid;
    grid-template-columns: 50vw 50vw;
}

#judge > div
{
    height: 25vw;
    --scale: 0.5;
}

</style>

<div style="position: absolute; background-color: rgba(255, 255, 255, 0.8);">

<h1>Play!</h1>

<%= @game.title %>

</div>

<div id="game">
    <div id="board-holder">
        <div id="board" class="dropzone" data-role="dropzone">
        </div>
    </div>
    <div id="hand" class="dropzone" data-role="dropzone" data-role-extra="hand">
    </div>
</div>

<div id="judge">
</div>

<template id="emoji-piece-template">
    <span class="dragitem"  data-role="dragitem"></span>
</template>

<script>

function text2CSS(text)
{
    const el = document.createElement('div');
    el.style.cssText = text;
    return el.style;

}

var cableFunc =
    () =>
    {
        // App.cableConsumer comes from consumer.js
        App.subc = App.cableConsumer.subscriptions.create(
            {
                channel: "GamesChannel",
                game_id: new URLSearchParams(document.location.search).get("game_id")
            },
            {
                connected() {
                // Called when the subscription is ready for use on the server
                console.log("cable connected");
                },

                disconnected() {
                // Called when the subscription has been terminated by the server
                console.log("cable disconnected");
                },

                received(data) {
                // Called when there's incoming data on the websocket for this channel
                    console.log("cable incoming", data);

                    if (data.cmd == "hand")
                    {
                        let handDiv = document.querySelector("#hand");
                        let boardDiv = document.querySelector("#board");
                        handDiv.innerHTML = boardDiv.innerHTML = "";
                        console.log(data.hand);
                        let hand = JSON.parse(data.hand);
                        console.log(hand);
                        gameState.hand = hand;
                        hand.forEach(emoji =>
                            {
                                let emel = document.querySelector("#emoji-piece-template").content.firstElementChild.cloneNode(true);
                                emel.innerHTML = emoji.raw;
                                emel.title = emoji.name;
                                if (emoji.position)
                                {
                                    let style = text2CSS(emoji.position);
                                    emel.style.left = style.left;
                                    emel.style.top = style.top;
                                    emel.style.position = style.position;
                                    if (style["--scale"]) emel.style["--scale"] = style["--scale"];
                                    boardDiv.appendChild(emel);
                                }
                                else
                                    handDiv.appendChild(emel);
                            })
                    }
                    else if (data.cmd == "judge")
                    {
                        let gameDiv = document.querySelector("#game");
                        let judgeDiv = document.querySelector("#judge");

                        gameDiv.hidden = true;
                        judgeDiv.hidden = false;
                    }
                    else if (data.cmd == "artist")
                    {
                        gameDiv.hidden = false;
                        judgeDiv.hidden = true;
                    }
                }
            }
        );
    };

if (document.readyState !== 'loading')
    cableFunc();
else
    addEventListener("DOMContentLoaded", cableFunc);


let game = document.querySelector("#game");

let gameState = {};

game.addEventListener("pointerdown",
    e =>
    {
        //console.log("pd", e);

        let role = e.target.dataset.role;

        if (role == "dragitem")
        {
            gameState.fromHand = e.target.parentNode.dataset.roleExtra == "hand";
            e.preventDefault();
            game.setPointerCapture(e.pointerId);
            gameState.dragging = e.target.cloneNode(true);
            gameState.dragOrig = e.target;
            e.target.parentNode.appendChild(gameState.dragging);
            e.target.classList.add("vis-hid");
            //console.log(gameState.dragging.classList);
            gameState.dragging.classList.add("dragitem-dragging");
            gameState.start = {x: e.pageX, y: e.pageY};
            gameState.dragging.dataset.x = e.target.offsetLeft - e.target.parentNode.scrollLeft;
            gameState.dragging.dataset.y = e.target.offsetTop; // + e.target.parentNode.offsetTop;
            gameState.dragging.style.left = `${gameState.dragging.dataset.x}px`;
            gameState.dragging.style.top = `${gameState.dragging.dataset.y}px`;
        }
    }
);

game.addEventListener("pointermove",
    e =>
    {
        if (!gameState.dragging) return;

        //console.log("pm", e.target.dataset.role, e);

        let hits = document.elementsFromPoint(e.clientX, e.clientY);

        let hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                hit.classList.add("dropzone-active");
                if (gameState.hot != hit)
                {
                    if (gameState.hot)
                        gameState.hot.classList.remove("dropzone-active");
                    gameState.hot = hit;
                }
                break;
            }
        }

        let t = gameState.dragging;

        //console.log(`${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px\n${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`);

        //console.log(`${Number(t.dataset.x)} + ${(e.pageX - gameState.start.x)}px`);

        t.style.left = `${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px`;
        t.style.top = `${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`;
    }
);

function getTop(elem)
{
    let rect = elem.getBoundingClientRect();
    return rect.top + window.scrollY;
}

function getLeft(elem)
{
    let rect = elem.getBoundingClientRect();
    return rect.left + window.scrollX;
}

game.addEventListener("pointerup",
    e =>
    {
        //console.log("pu", e.target.dataset.role, e);

        game.releasePointerCapture(e.pointerId);

        let hits = document.elementsFromPoint(e.clientX, e.clientY);

        let hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                break;
            }
        }

        let t = gameState.dragging;
        let d = hit;

        if (!t || !d) return;

        //gameState.dragging = null;

        //debugger;
        
        d.classList.remove("dropzone-active");

        /*
        t.addEventListener("transitionend",
            function tee(e)
            {
                debugger;
                */
               
               
               if (d.dataset.roleExtra == "hand")
                {
                    if (gameState.fromHand)
                    {
                        gameState.dragOrig.classList.remove("vis-hid");
                        t.remove();
                        gameState.dragging = null;
                    }
                    else
                    {
                        gameState.dragOrig.remove();

                        t.removeAttribute("style");
                        t.classList.remove("dragitem-dragging");
            
                        // find item dropped on
                        while ( hit = hits.pop() )
                        {
                            if (hit.dataset.role == "dragitem" && hit != gameState.dragging)
                            {
                                //console.log("hit", hit);
                                d.insertBefore(t, hit);
                                gameState.dragging = null;
                                return;
                            }
                        }
                        //debugger;
                        gameState.dragging = null;
                        d.appendChild(t);
                    }
                }
                else
                {
                    //let y = t.offsetTop - d.offsetTop;

                    gameState.dragOrig.remove();
                    gameState.dragging = null;
            
                    let x = getLeft(t) - d.offsetLeft;
                    let y = getTop(t) - d.offsetTop;

                    let width = t.offsetWidth;
                    let height = t.offsetHeight;

                    let left = x / (d.offsetWidth - width);
                    let top = y / (d.offsetHeight - height);
            
                    //console.log(Number(t.dataset.y) + (e.pageY - gameState.start.y));
            
                    /*
                    t.style.left = `${x}px`;
                    t.style.top = `${y}px`;
                   
                    t.style.left = `${left * 100}%`;
                    t.style.top = `${top * 100}%`;
                    */
                   
                   let size = t.style.fontSize || "15vmin";

                   t.style.left = `calc((100% - ${size} * var(--scale, 1)) * ${left})`;
                   t.style.top = `calc((100% - ${size} * var(--scale, 1)) * ${top})`;
                   
                   t.style.position = "absolute";
                   t.classList.remove("dragitem-dragging");
            
                   d.append(t);

                   //t.removeEventListener("transitionend", tee);
                }

                // fix up game hand:
                // move emoji to last spot

                let ind = gameState.hand.findIndex( el => el.name == t.title );

                let [em] = gameState.hand.splice(ind, 1);

                em.position = t.getAttribute("style");

                gameState.hand.push(em);

                App.subc.perform("update", { hand: gameState.hand });
            /*
            }
        );
        */
    }
);

</script>