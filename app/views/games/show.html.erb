<% content_for :title, "Play Emoji2Emoji" %>

<style>

*
{
    box-sizing: border-box;
    /*touch-action: none;*/
}

@media (orientation: portrait)
{
    *
    {
        --board-y: 50vw;
        --board-x: 100vw;
    }

}

body
{
    margin: 0;
    overflow: hidden;
    height: 100vh;
    
    user-select: none;
    -webkit-user-select: none; /* Safari */

    --board-y: 50vh;
    --board-x: 100vh;
    --base-size: 15vmin;
}

#game
{
    touch-action: none;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    height: 100%;
}

#board
{
    width: var(--board-x);
    height: var(--board-y);
    flex: unset;
}

#board-holder
{
    display: flex;
    justify-content: center;
    align-items: center;
}

.dragitem
{
    line-height: 100%;
    font-size: calc(var(--base-size) * var(--scale, 1));
    transform: scale(var(--flipX, 1), var(--flipY, 1));
}

.dropzone
{
    /*
    width: 50vmin;
    height: 35vmax;
    */
    position: relative;
    display: inline-block;
    outline: 1px solid black;
    flex: 1; /* => grow: 1 shrink: 1 basis: 0 */
}

#main > .dragitem
{

}

.dropzone-active
{
    box-shadow: inset 0px 0px 20px rgba(255, 100, 100, 0.5);
}

.dragitem-dragging
{
    /*transform: scale(300%);*/
    z-index: 10;
    position: absolute;
}

#hand
{
    padding: 3vmin;
}

.vis-hid
{
    visibility: hidden;
}

.gone
{
    display: none !important;
}

#judge
{
    width: 100vw;
    height: 100vh;
}

#field
{
    display: grid;
    grid-template-columns: 50vw 50vw;
    --base-size: 7.5vw;
}

#field > div
{
    height: 25vw;
    position: relative;
    outline: 1px solid black;
}

#field > div > span
{
    font-size: calc(var(--base-size) * var(--scale, 1));
    transform: scale(var(--flipX, 1), var(--flipY, 1));
}

#countdown
{
    position: absolute;
    display: flex;
    justify-content: center;
    align-items: center;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

#countdown > div
{
    animation: 1s ease-out bloom;
}

@keyframes bloom
{
    from
    {
        transform: scale(1);
        opacity: 100%;
    }

    60%
    {
        opacity: 100%;
    }

    to
    {
        transform: scale(50);
        opacity: 0%;
    }
}

#menu-btn
{
    position: absolute;
    bottom: 0;
    right: 0;
    margin: 0.3em;
    border-radius: 1em;
    padding: 0.25em;
    background-color: lightblue;
    font-size: 7vmin;
}

#menu
{
    position: absolute;
    padding: 0.3em;
    background-color: lightgrey;
    border: 0.25em outset grey;
    border-radius: 0.25em;
    z-index: 20;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;

    font-size: 10vmin;

    display: flex;
    flex-direction: column;
    overflow: auto;
}

#menu-spacer
{
    flex-grow: 1;
}

#menu-emoji
{
    font-size: 15vmin;
    /*text-align: center;*/
}

#menu-emoji-title
{
    font-size: 66.6%;
    font-style: italic;
}

#menu > div > div:hover
{
    background-color: lightblue;
}

#close-menu
{
    /*
    position: absolute;
    bottom: 0;
    width: calc(100% - 0.6em); */ /* minus padding */
}

.selected
{
    filter: drop-shadow(-1px -1px 0 red)
            drop-shadow(1px -1px 0 red)
            drop-shadow(-1px 1px 0 red)
            drop-shadow(1px 1px 0 red);
}

</style>

<div style="position: absolute; bottom: 0; right: 0; background-color: rgba(255, 255, 255, 0.8);">
    <%= @game.title %>
</div>

<div style="position: absolute; bottom: 0; left: 0; background-color: rgba(255, 255, 255, 0.8); z-index: 15;">
<h2>emoji <span id="prompt"></span></h2>
</div>

<div id="game">
    <div id="board-holder">
        <div id="board" class="dropzone" data-role="dropzone">
        </div>
    </div>
    <div id="hand" class="dropzone" data-role="dropzone" data-role-extra="hand">
    </div>
</div>

<div id="judge">
    <div id="judge-panel">
        <button
            style="font-size: 16vw;"
            onclick="startCountdown()">
            Start Countdown
        </button>
    </div>
    <div id="field"></div>
</div>

<div id="menu-btn" onclick="showMenu(event);">â˜°</div>

<div id="menu" class="gone">
    <div id="menu-emoji-section">
        <div id="menu-emoji"></div>
        <div id="change-scale" onclick="scaleEmoji();">Scale Emoji</div>
        <div id="change-scale" onclick="flipEmoji('X');">Flip Horizontal</div>
        <div id="change-scale" onclick="flipEmoji('Y');">Flip Vertical</div>
        <div id="trade-in" onclick="tradeIn();">Trade In Emoji</div>
        <hr>
    </div>
    <div id="menu-game-section">
        <div id="trade-in" onclick=";">Set Name</div>
        <div id="trade-in" onclick=";">Exit Game</div>
        <hr>
    </div>
    <div id="menu-spacer"></div>
    <div id="menu-close-section">
        <div id="close-menu" onclick="closeMenu();">Close</div>
    </div>
</div>

<div id="countdown"></div>

<template id="emoji-piece-template">
    <span class="dragitem"  data-role="dragitem"></span>
</template>

<script>

function text2CSS(text)
{
    const el = document.createElement('div');
    el.style.cssText = text;
    return el.style;

}

var gameDiv = document.querySelector("#game");
var handDiv = document.querySelector("#hand");
var boardDiv = document.querySelector("#board");
var judgeDiv = document.querySelector("#judge");
var judgePanelDiv = document.querySelector("#judge-panel");
var fieldDiv = document.querySelector("#field");
var countdownDiv = document.querySelector("#countdown");
var menuDiv = document.querySelector("#menu");
var menuEmojiDiv = document.querySelector("#menu-emoji");
var menuEmojiSectionDiv = document.querySelector("#menu-emoji-section");
var promptDiv = document.querySelector("#prompt");

window.App = window.App || {}

function startCountdown()
{

    App.subc.perform("start_countdown");
}

function showMenu(e)
{
    if (gameState.selectedEmoji)
    {
        menuEmojiSectionDiv.classList.remove("gone");
        menuEmojiDiv.innerHTML = `${gameState.selectedEmoji.innerHTML} <span id="menu-emoji-title"> - ${gameState.selectedEmoji.title}</span>`;
    }
    else
        menuEmojiSectionDiv.classList.add("gone");

    menuDiv.classList.remove("gone");
    menuDiv.scrollTo(0, 0);

    gameState.menuOpen = true;

    gameState.menuTimer = null;
}

function closeMenu()
{
    menuDiv.classList.add("gone");
    gameState.menuOpen = false;
}

function scaleEmoji()
{
    emel = gameState.selectedEmoji;

    let s = prompt("Enter scale factor as a decimal, (e.g. 0.75):");
    if (!s) return;
    let sf = Number(s);
    emel.style.setProperty("--scale", sf);

    // send update
    var em = gameState.hand.find( el => el.name == emel.title );
    em.position = emel.getAttribute("style");

    App.subc.perform("update", { hand: gameState.hand });

    closeMenu();
}

function flipEmoji(axis)
{
    emel = gameState.selectedEmoji;

    let csf = emel.style.getPropertyValue(`--flip${axis}`) || 1;
    emel.style.setProperty(`--flip${axis}`, -csf);

    // send update
    var em = gameState.hand.find( el => el.name == emel.title );
    em.position = emel.getAttribute("style");

    App.subc.perform("update", { hand: gameState.hand });

    closeMenu();
}

function tradeIn()
{
    emel = gameState.selectedEmoji;

    App.subc.perform("trade_in", { emoji: emel.title });

    closeMenu();
}

var cableFunc =
    () =>
    {
        // if consumer isn't loaded, set callback to this function and exit
        if (!App.cableConsumer)
        {
            App.cableConsumerCallback = cableFunc;
            return;
        }

        // App.cableConsumer comes from consumer.js
        App.subc = App.cableConsumer.subscriptions.create(
            {
                channel: "GamesChannel",
                game_id: new URLSearchParams(document.location.search).get("game_id")
            },
            {
                connected() {
                // Called when the subscription is ready for use on the server
                console.log("cable connected");
                },

                disconnected() {
                // Called when the subscription has been terminated by the server
                console.log("cable disconnected");
                },

                received(data) {
                // Called when there's incoming data on the websocket for this channel
                    console.log("cable incoming", data);

                    // fix up new round command
                    if (data.broadcast)
                    {
                        data = data.broadcast.find( el => el.player == gameState.player ).data;
                        console.log("broadcast data:", data);
                    }

                    if (data.id)
                    {
                        gameState.player = data.id;
                    }
                    if (data.prompt)
                    {
                        promptDiv.innerHTML = data.prompt;
                    }
                    if (data.hand)
                    {
                        handDiv.innerHTML = boardDiv.innerHTML = "";
                        console.log(data.hand);
                        var hand = data.hand; //JSON.parse(data.hand);
                        console.log(hand);
                        gameState.hand = hand;
                        hand.forEach(
                            emoji =>
                            {
                                var emel = document.querySelector("#emoji-piece-template").content.firstElementChild.cloneNode(true);
                                emel.innerHTML = emoji.raw;
                                emel.title = emoji.name;
                                if (emoji.position)
                                {
                                    var style = text2CSS(emoji.position);
                                    emel.style.left = style.left;
                                    emel.style.top = style.top;
                                    emel.style.position = style.position;
                                    if (style.getPropertyValue("--scale")) emel.style.setProperty("--scale", style.getPropertyValue("--scale"));
                                    if (style.getPropertyValue("--flipX")) emel.style.setProperty("--flipX", style.getPropertyValue("--flipX"));
                                    if (style.getPropertyValue("--flipY")) emel.style.setProperty("--flipY", style.getPropertyValue("--flipY"));
                                    //console.log(style.getPropertyValue("--flipY"), emel.style.getPropertyValue("--flipY"));
                                    boardDiv.appendChild(emel);
                                }
                                else
                                    handDiv.appendChild(emel);
                            });
                    }
                    if (data.role)
                    {
                        gameState.role = data.role;

                        if (data.role == "judge")
                        {
                            gameState.chosen = undefined;

                            field.innerHTML = "";

                            gameDiv.classList.add("gone")
                            judgeDiv.classList.remove("gone")
                            judgePanelDiv.classList.remove("gone");
                        }
                        else if (data.role == "artist")
                        {
                            gameDiv.classList.remove("gone");
                            judgeDiv.classList.add("gone");
                        }
                    }

                    // cmds
                    if (data.cmd == "countdown")
                    {
                        if (document.visibilityState == "hidden") return;

                        console.log("countdown", data);
                        let nd = document.createElement("div");
                        nd.innerHTML = data.time;
                        countdownDiv.appendChild(nd);
                        nd.addEventListener("animationend", () => nd.remove());
                    }
                    else if (data.cmd == "show-em")
                    {
                        gameDiv.classList.add("gone");
                        judgeDiv.classList.remove("gone");
                        judgePanelDiv.classList.add("gone");

                        field.innerHTML = "";
                        gameState.gallery = {}
                        data.all.forEach(
                            player =>
                            {
                                let d = document.createElement("div");
                                player.art.forEach(
                                    emoji =>
                                    {
                                        var emel = document.querySelector("#emoji-piece-template").content.firstElementChild.cloneNode(true);
                                        emel.innerHTML = emoji.raw;
                                        emel.title = emoji.name;
                                        var style = text2CSS(emoji.position);
                                        emel.style.left = style.left;
                                        emel.style.top = style.top;
                                        emel.style.position = style.position;
                                        if (style.getPropertyValue("--scale")) emel.style.setProperty("--scale", style.getPropertyValue("--scale"));
                                        if (style.getPropertyValue("--flipX")) emel.style.setProperty("--flipX", style.getPropertyValue("--flipX"));
                                        if (style.getPropertyValue("--flipY")) emel.style.setProperty("--flipY", style.getPropertyValue("--flipY"));
                                        d.appendChild(emel);

                                        //emel.dataset.player = player.id;
                                    });

                                // allow judge to pick winner
                                gameState.gallery[player.player] = d;
                                if (gameState.role == "judge")
                                {
                                    d.addEventListener("click",
                                        e =>
                                        {
                                            if (gameState.chosen) return;
                                            console.log("pick player", player);
                                            App.subc.perform("pick", { player: player.player });
                                            gameState.chosen = player.player;
                                        });
                                }
                                field.appendChild(d);
                            }
                        )
                    }
                    else if (data.cmd == "pick")
                    {
                        gameState.gallery[data.player].style.outline = "5px solid red";
                        gameState.gallery[data.player].style.backgroundColor = "pink";
                    }
                }
            }
        );
    };

if (document.readyState !== 'loading')
    cableFunc();
else
    addEventListener("DOMContentLoaded", cableFunc);

var gameState = {};

// prevent browser contextual menu
game.addEventListener("contextmenu", e => e.preventDefault());

game.addEventListener("pointerdown",
    e =>
    {
        console.log("pd", gameState.menuOpen, e);

        // ignore if menu open
        if (gameState.menuOpen) return;

        gameState.start = {x: e.pageX, y: e.pageY};

        gameState.clickTime = Date.now();
        gameState.distance = 0;

        //if (e.target.dataset.role != "dragitem") return;

        // will likely be overwritten by pm wiggle
        if (e.target != gameState.selectedEmoji)
        {
            if (gameState.selectedEmoji)
                gameState.selectedEmoji.classList.remove("selected")
            
            if (e.target.dataset.role == "dragitem")
            {
                gameState.selectedEmoji =  e.target;
                gameState.selectedEmoji.classList.add("selected");
            }
            else
                gameState.selectedEmoji =  null;
        }

        gameState.clickCache = gameState.selectedEmoji;
    }
);

game.addEventListener("pointermove",
    e =>
    {
        //console.log("pm", gameState.dragging);
        
        // delay this until drag actually starts
        // selectedEmoji comes from pointerdown
        // will be equal to e.target
        if (gameState.clickCache && !gameState.dragging)
        {
            // start drag
            var role = gameState.selectedEmoji.dataset.role;

            if (role == "dragitem")
            {
                gameState.fromHand = e.target.parentNode.dataset.roleExtra == "hand";
                game.setPointerCapture(e.pointerId);
                gameState.dragging = e.target.cloneNode(true);
                gameState.selectedEmoji = gameState.dragging;
                gameState.dragOrig = e.target;
                e.target.parentNode.appendChild(gameState.dragging);
                e.target.classList.add("vis-hid");
                //console.log(gameState.dragging.classList);
                gameState.dragging.classList.add("dragitem-dragging");
                gameState.dragging.dataset.x = e.target.offsetLeft - e.target.parentNode.scrollLeft;
                gameState.dragging.dataset.y = e.target.offsetTop; // + e.target.parentNode.offsetTop;
                gameState.dragging.style.left = `${gameState.dragging.dataset.x}px`;
                gameState.dragging.style.top = `${gameState.dragging.dataset.y}px`;
            }
        }

        if (!gameState.dragging) return;

        e.preventDefault();

        var hits = document.elementsFromPoint(e.clientX, e.clientY);

        var hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                hit.classList.add("dropzone-active");
                if (gameState.hot != hit)
                {
                    if (gameState.hot)
                        gameState.hot.classList.remove("dropzone-active");
                    gameState.hot = hit;
                }
                break;
            }
        }

        var t = gameState.dragging;

        //console.log(`${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px\n${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`);

        //console.log(`${Number(t.dataset.x)} + ${(e.pageX - gameState.start.x)}px`);

        t.style.left = `${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px`;
        t.style.top = `${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`;

        // get distance for showing menu
        let curd = Math.sqrt(
            Math.abs(gameState.start.x - e.pageX) ** 2 +
            Math.abs(gameState.start.y - e.pageY) ** 2
        );
        gameState.distance = Math.max(gameState.distance, curd);
    }
);

function getTop(elem)
{
    var rect = elem.getBoundingClientRect();
    return rect.top + window.scrollY;
}

function getLeft(elem)
{
    var rect = elem.getBoundingClientRect();
    return rect.left + window.scrollX;
}

game.addEventListener("pointerup",
    e =>
    {
        console.log("pu", e.target.dataset.role, e);

        if (gameState.menuTimer)
        {
            clearTimeout(gameState.menuTimer);
            gameState.menuTimer = null;
        }

        gameState.clickCache = null;

        game.releasePointerCapture(e.pointerId);

        var hits = document.elementsFromPoint(e.clientX, e.clientY);

        var hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                break;
            }
        }

        var t = gameState.dragging;
        var d = hit;

        if (!t || !d) return;

        //gameState.dragging = null;

        //debugger;
        
        d.classList.remove("dropzone-active");

        /*
        t.addEventListener("transitionend",
            function tee(e)
            {
                debugger;
                */
               
               
                if (d.dataset.roleExtra == "hand")
                {
                    // items in hand should have no style attribute
                    t.removeAttribute("style");

                    /*
                    if (gameState.fromHand)
                    {
                        gameState.dragOrig.classList.remove("vis-hid");
                        t.remove();
                        gameState.dragging = null;
                    }
                    else
                    {
                        */
                        gameState.dragOrig.remove();

                        t.classList.remove("dragitem-dragging");
            
                        /* don't bother:

                        // find item dropped on
                        while ( hit = hits.pop() )
                        {
                            if (hit.dataset.role == "dragitem" && hit != gameState.dragging)
                            {
                                //console.log("hit", hit);
                                d.insertBefore(t, hit);
                                gameState.dragging = null;

                                // send update
                                var em = gameState.hand.find( el => el.name == t.title );
                                em.position = t.getAttribute("style");

                                App.subc.perform("update", { hand: gameState.hand });
                                return;
                            }
                        }
                        */

                        //debugger;
                        gameState.dragging = null;
                        d.appendChild(t);
                    //}
                }
                else
                {
                    //var y = t.offsetTop - d.offsetTop;

                    gameState.dragOrig.remove();
                    gameState.dragging = null;
            
                    var x = getLeft(t) - d.offsetLeft;
                    var y = getTop(t) - d.offsetTop;

                    var width = t.offsetWidth;
                    var height = t.offsetHeight;

                    var left = x / (d.offsetWidth - width);
                    var top = y / (d.offsetHeight - height);
            
                    //console.log(Number(t.dataset.y) + (e.pageY - gameState.start.y));
            
                    /*
                    t.style.left = `${x}px`;
                    t.style.top = `${y}px`;
                   
                    t.style.left = `${left * 100}%`;
                    t.style.top = `${top * 100}%`;
                    */

                   t.style.left = `calc((100% - var(--base-size) * var(--scale, 1)) * ${left})`;
                   t.style.top = `calc((100% - var(--base-size) * var(--scale, 1)) * ${top})`;
                   
                   t.style.position = "absolute";
                   t.classList.remove("dragitem-dragging");
            
                   d.append(t);

                   //t.removeEventListener("transitionend", tee);
                }

                // fix up game hand:
                // move emoji to last spot

                var ind = gameState.hand.findIndex( el => el.name == t.title );

                var [em] = gameState.hand.splice(ind, 1);

                em.position = t.getAttribute("style");

                gameState.hand.push(em);

                App.subc.perform("update", { hand: gameState.hand });
            /*
            }
        );
        */
    }
);

</script>