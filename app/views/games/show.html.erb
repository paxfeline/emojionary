<% content_for :title, "Play Emoji2Emoji" %>

<style>

*
{
    box-sizing: border-box;
}

@media (orientation: portrait)
{
    *
    {
        --board-y: 50vw;
        --board-x: 100vw;
    }

}

body
{
    margin: 0;
    overflow: hidden;
    height: 100vh;
    user-select: none;
    -webkit-user-select: none; /* Safari */

    --board-y: 50vh;
    --board-x: 100vh;
    --base-size: 15vmin;
}

#game
{
    touch-action: none;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    width: 100%;
    height: 100%;
}

#board
{
    width: var(--board-x);
    height: var(--board-y);
    flex: unset;
}

#board-holder
{
    display: flex;
    justify-content: center;
    align-items: center;
}

.dragitem
{
    transition: transform 0.25s;
    border-radius: 50%;
    line-height: 100%;
    font-size: calc(var(--base-size) * var(--scale, 1));
}

.dropzone
{
    /*
    width: 50vmin;
    height: 35vmax;
    */
    position: relative;
    display: inline-block;
    outline: 1px solid black;
    flex: 1; /* => grow: 1 shrink: 1 basis: 0 */
}

#main > .dragitem
{

}

.dropzone-active
{
    box-shadow: inset 0px 0px 20px rgba(255, 100, 100, 0.5);
}

.dragitem-dragging
{
    /*transform: scale(300%);*/
    z-index: 10;
    position: absolute;
}

#hand
{
    padding: 3vmin;
}

.vis-hid
{
    visibility: hidden;
}

.gone
{
    display: none !important;
}

#judge
{
    width: 100vw;
    height: 100vh;
}

#field
{
    display: grid;
    grid-template-columns: 50vw 50vw;
    --base-size: 7.5vw;
}

#field > div
{
    height: 25vw;
    position: relative;
    outline: 1px solid black;
}

</style>

<div style="position: absolute; bottom: 0; right: 0; background-color: rgba(255, 255, 255, 0.8);">

<%= @game.title %>

</div>

<div id="game">
    <div id="board-holder">
        <div id="board" class="dropzone" data-role="dropzone">
        </div>
    </div>
    <div id="hand" class="dropzone" data-role="dropzone" data-role-extra="hand">
    </div>
</div>

<div id="judge">
    <div id="judge-panel">
        <button
            onclick="startCountdown()">
            Start Countdown
        </button>
    </div>
    <div id="countdown"></div>
    <div id="field"></div>
</div>

<template id="emoji-piece-template">
    <span class="dragitem"  data-role="dragitem"></span>
</template>

<script>

function text2CSS(text)
{
    const el = document.createElement('div');
    el.style.cssText = text;
    return el.style;

}

var handDiv = document.querySelector("#hand");
var boardDiv = document.querySelector("#board");
var gameDiv = document.querySelector("#game");
var judgeDiv = document.querySelector("#judge");
var judgePanelDiv = document.querySelector("#judge-panel");
var countdownDiv = document.querySelector("#countdown");
var fieldDiv = document.querySelector("#field");

window.App = window.App || {}

function startCountdown()
{

    App.subc.perform("start_countdown");
}

var cableFunc =
    () =>
    {
        // if consumer isn't loaded, set callback to this function and exit
        if (!App.cableConsumer)
        {
            App.cableConsumerCallback = cableFunc;
            return;
        }

        // App.cableConsumer comes from consumer.js
        App.subc = App.cableConsumer.subscriptions.create(
            {
                channel: "GamesChannel",
                game_id: new URLSearchParams(document.location.search).get("game_id")
            },
            {
                connected() {
                // Called when the subscription is ready for use on the server
                console.log("cable connected");
                },

                disconnected() {
                // Called when the subscription has been terminated by the server
                console.log("cable disconnected");
                },

                received(data) {
                // Called when there's incoming data on the websocket for this channel
                    console.log("cable incoming", data);

                    // fix up new round command
                    if (data.cmd == "new-round")
                    {
                        data.cmd = data.all.find( el => el.player == gameState.player ).role;
                        console.log("new round role:", data.cmd);
                    }

                    if (data.cmd == "id")
                    {
                        gameState.player = data.id;
                    }
                    else if (data.cmd == "hand")
                    {
                        handDiv.innerHTML = boardDiv.innerHTML = "";
                        console.log(data.hand);
                        var hand = JSON.parse(data.hand);
                        console.log(hand);
                        gameState.hand = hand;
                        hand.forEach(
                            emoji =>
                            {
                                var emel = document.querySelector("#emoji-piece-template").content.firstElementChild.cloneNode(true);
                                emel.innerHTML = emoji.raw;
                                emel.title = emoji.name;
                                if (emoji.position)
                                {
                                    var style = text2CSS(emoji.position);
                                    emel.style.left = style.left;
                                    emel.style.top = style.top;
                                    emel.style.position = style.position;
                                    if (style["--scale"]) emel.style["--scale"] = style["--scale"];
                                    boardDiv.appendChild(emel);
                                }
                                else
                                    handDiv.appendChild(emel);
                            });
                    }
                    else if (data.cmd == "judge")
                    {
                        gameState.role = "judge";
                        gameState.chosen = undefined;

                        field.innerHTML = "";

                        gameDiv.classList.add("gone")
                        judgeDiv.classList.remove("gone")
                        judgePanelDiv.classList.remove("gone");
                    }
                    else if (data.cmd == "artist")
                    {
                        gameState.role = "artist";

                        gameDiv.classList.remove("gone");
                        judgeDiv.classList.add("gone");
                    }
                    else if (data.cmd == "countdown")
                    {
                        console.log(data);
                    }
                    else if (data.cmd == "show-em")
                    {
                        gameDiv.classList.add("gone");
                        judgeDiv.classList.remove("gone");
                        judgePanelDiv.classList.add("gone");

                        field.innerHTML = "";
                        gameState.gallery = {}
                        data.all.forEach(
                            player =>
                            {
                                let d = document.createElement("div");
                                player.art.forEach(
                                    emoji =>
                                    {
                                        var emel = document.querySelector("#emoji-piece-template").content.firstElementChild.cloneNode(true);
                                        emel.innerHTML = emoji.raw;
                                        emel.title = emoji.name;
                                        var style = text2CSS(emoji.position);
                                        emel.style.left = style.left;
                                        emel.style.top = style.top;
                                        emel.style.position = style.position;
                                        if (style["--scale"]) emel.style["--scale"] = style["--scale"];
                                        d.appendChild(emel);

                                        //emel.dataset.player = player.id;
                                    });

                                // allow judge to pick winner
                                gameState.gallery[player.player] = d;
                                if (gameState.role == "judge")
                                {
                                    d.addEventListener("click",
                                        e =>
                                        {
                                            if (gameState.chosen) return;
                                            console.log("pick player", player);
                                            App.subc.perform("pick", { player: player.player });
                                            gameState.chosen = player.player;
                                        });
                                }
                                field.appendChild(d);
                            }
                        )
                    }
                    else if (data.cmd == "pick")
                    {
                        gameState.gallery[data.player].style.border = "5px solid red";
                    }
                }
            }
        );
    };

if (document.readyState !== 'loading')
    cableFunc();
else
    addEventListener("DOMContentLoaded", cableFunc);

var gameState = {};

game.addEventListener("pointerdown",
    e =>
    {
        //console.log("pd", e);

        var role = e.target.dataset.role;

        if (role == "dragitem")
        {
            e.preventDefault();
            gameState.fromHand = e.target.parentNode.dataset.roleExtra == "hand";
            game.setPointerCapture(e.pointerId);
            gameState.dragging = e.target.cloneNode(true);
            gameState.dragOrig = e.target;
            e.target.parentNode.appendChild(gameState.dragging);
            e.target.classList.add("vis-hid");
            //console.log(gameState.dragging.classList);
            gameState.dragging.classList.add("dragitem-dragging");
            gameState.start = {x: e.pageX, y: e.pageY};
            gameState.dragging.dataset.x = e.target.offsetLeft - e.target.parentNode.scrollLeft;
            gameState.dragging.dataset.y = e.target.offsetTop; // + e.target.parentNode.offsetTop;
            gameState.dragging.style.left = `${gameState.dragging.dataset.x}px`;
            gameState.dragging.style.top = `${gameState.dragging.dataset.y}px`;
        }
    }
);

game.addEventListener("pointermove",
    e =>
    {
        if (!gameState.dragging) return;

        //console.log("pm", e.target.dataset.role, e);

        var hits = document.elementsFromPoint(e.clientX, e.clientY);

        var hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                hit.classList.add("dropzone-active");
                if (gameState.hot != hit)
                {
                    if (gameState.hot)
                        gameState.hot.classList.remove("dropzone-active");
                    gameState.hot = hit;
                }
                break;
            }
        }

        var t = gameState.dragging;

        //console.log(`${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px\n${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`);

        //console.log(`${Number(t.dataset.x)} + ${(e.pageX - gameState.start.x)}px`);

        t.style.left = `${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px`;
        t.style.top = `${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`;
    }
);

function getTop(elem)
{
    var rect = elem.getBoundingClientRect();
    return rect.top + window.scrollY;
}

function getLeft(elem)
{
    var rect = elem.getBoundingClientRect();
    return rect.left + window.scrollX;
}

game.addEventListener("pointerup",
    e =>
    {
        //console.log("pu", e.target.dataset.role, e);

        game.releasePointerCapture(e.pointerId);

        var hits = document.elementsFromPoint(e.clientX, e.clientY);

        var hit;
        while ( hit = hits.pop() )
        {
            if (hit.dataset.role == "dropzone")
            {
                //console.log("hit", hit);
                break;
            }
        }

        var t = gameState.dragging;
        var d = hit;

        if (!t || !d) return;

        //gameState.dragging = null;

        //debugger;
        
        d.classList.remove("dropzone-active");

        /*
        t.addEventListener("transitionend",
            function tee(e)
            {
                debugger;
                */
               
               
                if (d.dataset.roleExtra == "hand")
                {
                    // items in hand should have no style attribute
                    t.removeAttribute("style");

                    if (gameState.fromHand)
                    {
                        gameState.dragOrig.classList.remove("vis-hid");
                        t.remove();
                        gameState.dragging = null;
                    }
                    else
                    {
                        gameState.dragOrig.remove();

                        t.classList.remove("dragitem-dragging");
            
                        // find item dropped on
                        while ( hit = hits.pop() )
                        {
                            if (hit.dataset.role == "dragitem" && hit != gameState.dragging)
                            {
                                //console.log("hit", hit);
                                d.insertBefore(t, hit);
                                gameState.dragging = null;

                                // send update
                                var em = gameState.hand.find( el => el.name == t.title );
                                em.position = t.getAttribute("style");

                                App.subc.perform("update", { hand: gameState.hand });
                                return;
                            }
                        }
                        //debugger;
                        gameState.dragging = null;
                        d.appendChild(t);
                    }
                }
                else
                {
                    //var y = t.offsetTop - d.offsetTop;

                    gameState.dragOrig.remove();
                    gameState.dragging = null;
            
                    var x = getLeft(t) - d.offsetLeft;
                    var y = getTop(t) - d.offsetTop;

                    var width = t.offsetWidth;
                    var height = t.offsetHeight;

                    var left = x / (d.offsetWidth - width);
                    var top = y / (d.offsetHeight - height);
            
                    //console.log(Number(t.dataset.y) + (e.pageY - gameState.start.y));
            
                    /*
                    t.style.left = `${x}px`;
                    t.style.top = `${y}px`;
                   
                    t.style.left = `${left * 100}%`;
                    t.style.top = `${top * 100}%`;
                    */

                   t.style.left = `calc((100% - var(--base-size) * var(--scale, 1)) * ${left})`;
                   t.style.top = `calc((100% - var(--base-size) * var(--scale, 1)) * ${top})`;
                   
                   t.style.position = "absolute";
                   t.classList.remove("dragitem-dragging");
            
                   d.append(t);

                   //t.removeEventListener("transitionend", tee);
                }

                // fix up game hand:
                // move emoji to last spot

                var ind = gameState.hand.findIndex( el => el.name == t.title );

                var [em] = gameState.hand.splice(ind, 1);

                em.position = t.getAttribute("style");

                gameState.hand.push(em);

                App.subc.perform("update", { hand: gameState.hand });
            /*
            }
        );
        */
    }
);

</script>